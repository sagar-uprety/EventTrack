"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var P = require('bluebird');

var _ = require('lodash');

var express = require('express');

var path = require('path');

var fs = require('fs');

var cors = require('cors');

var bodyParser = require('body-parser');

var jwt = require('express-jwt');

var requireAll = require('require-all');

var auth = require('./services/auth');

var ResourcesRoutes = require('./routes/resources');

var ActionsRoutes = require('./routes/actions');

var AssociationsRoutes = require('./routes/associations');

var StatRoutes = require('./routes/stats');

var SessionRoute = require('./routes/sessions');

var ForestRoutes = require('./routes/forest');

var HealthCheckRoute = require('./routes/healthcheck');

var Schemas = require('./generators/schemas');

var SchemaSerializer = require('./serializers/schema');

var logger = require('./services/logger');

var pathService = require('./services/path');

var Integrator = require('./integrations');

var errorHandler = require('./services/error-handler');

var ApimapSender = require('./services/apimap-sender');

var ipWhitelist = require('./services/ip-whitelist');

var SchemaFileUpdater = require('./services/schema-file-updater');

var ApimapFieldsFormater = require('./services/apimap-fields-formater');

var ConfigStore = require('./services/config-store');

var ProjectDirectoryUtils = require('./utils/project-directory');

var pathProjectAbsolute = new ProjectDirectoryUtils().getAbsolutePath();
var ENVIRONMENT_DEVELOPMENT = !process.env.NODE_ENV || ['dev', 'development'].includes(process.env.NODE_ENV);
var SCHEMA_FILENAME = "".concat(pathProjectAbsolute, "/.forestadmin-schema.json");
var DISABLE_AUTO_SCHEMA_APPLY = process.env.FOREST_DISABLE_AUTO_SCHEMA_APPLY && JSON.parse(process.env.FOREST_DISABLE_AUTO_SCHEMA_APPLY);
var REGEX_COOKIE_SESSION_TOKEN = /forest_session_token=([^;]*)/;
var configStore = ConfigStore.getInstance();
var jwtAuthenticator;

function getModels() {
  var models = configStore.Implementation.getModels();

  _.each(models, function (model, modelName) {
    model.modelName = modelName;
  });

  return _.values(models);
}

function requireAllModels(modelsDir) {
  if (modelsDir) {
    try {
      var isJavascriptOrTypescriptFileName = function isJavascriptOrTypescriptFileName(fileName) {
        return fileName.endsWith('.js') || fileName.endsWith('.ts') && !fileName.endsWith('.d.ts');
      }; // NOTICE: Ends with `.spec.js`, `.spec.ts`, `.test.js` or `.test.ts`.


      var isTestFileName = function isTestFileName(fileName) {
        return fileName.match(/(?:\.test|\.spec)\.(?:js||ts)$/g);
      };

      requireAll({
        dirname: modelsDir,
        excludeDirs: /^__tests__$/,
        filter: function filter(fileName) {
          return isJavascriptOrTypescriptFileName(fileName) && !isTestFileName(fileName);
        },
        recursive: true
      });
    } catch (error) {
      logger.error('Cannot read a file for the following reason: ', error);
    }
  } // NOTICE: User didn't provide a modelsDir but may already have required them manually so they
  //         might be available.


  return P.resolve(getModels())["catch"](function (error) {
    logger.error('Cannot read a file for the following reason: ', error);
    return P.resolve([]);
  });
}

exports.Schemas = Schemas;
exports.logger = logger;
exports.ResourcesRoute = {};

exports.ensureAuthenticated = function (request, response, next) {
  auth.authenticate(request, response, next, jwtAuthenticator);
};

var app = null;

function buildSchema() {
  var lianaOptions = configStore.lianaOptions,
      Implementation = configStore.Implementation;
  var absModelDirs = configStore.modelsDir ? path.resolve('.', configStore.modelsDir) : undefined;
  return requireAllModels(absModelDirs).then(function _callee(models) {
    return _regenerator["default"].async(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            configStore.integrator = new Integrator(lianaOptions, Implementation);
            _context.next = 3;
            return _regenerator["default"].awrap(Schemas.perform(Implementation, configStore.integrator, models, lianaOptions));

          case 3:
            return _context.abrupt("return", models);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    });
  });
}

exports.init = function (Implementation) {
  var opts = Implementation.opts;
  configStore.Implementation = Implementation;
  configStore.lianaOptions = opts;

  if (opts.onlyCrudModule === true) {
    return buildSchema();
  }

  if (app) {
    logger.warn('Forest init function called more than once. Only the first call has been processed.');
    return app;
  }

  app = express();
  var pathMounted = pathService.generate('*', opts);
  auth.initAuth(opts);

  if (opts.secretKey) {
    logger.warn('DEPRECATION WARNING: The use of secretKey and authKey options is deprecated. Please use envSecret and authSecret instead.');
    opts.envSecret = opts.secretKey;
    opts.authSecret = opts.authKey;
  } // CORS


  var allowedOrigins = ['localhost:4200', /\.forestadmin\.com$/];

  if (process.env.CORS_ORIGINS) {
    allowedOrigins = allowedOrigins.concat(process.env.CORS_ORIGINS.split(','));
  }

  app.use(pathMounted, cors({
    origin: allowedOrigins,
    maxAge: 86400,
    // NOTICE: 1 day
    credentials: true
  })); // Mime type

  app.use(pathMounted, bodyParser.json()); // Authentication

  if (opts.authSecret) {
    jwtAuthenticator = jwt({
      secret: opts.authSecret,
      credentialsRequired: false,
      getToken: function getToken(request) {
        if (request.headers) {
          if (request.headers.authorization && request.headers.authorization.split(' ')[0] === 'Bearer') {
            return request.headers.authorization.split(' ')[1];
          } // NOTICE: Necessary for downloads authentication.


          if (request.headers.cookie) {
            var match = request.headers.cookie.match(REGEX_COOKIE_SESSION_TOKEN);

            if (match && match[1]) {
              return match[1];
            }
          }
        }

        return null;
      }
    });
  } else {
    logger.error('Your Forest authSecret seems to be missing. Can you check that you properly set a Forest authSecret in the Forest initializer?');
  }

  if (!opts.envSecret) {
    logger.error('Your Forest envSecret seems to be missing. Can you check that you properly set a Forest envSecret in the Forest initializer?');
  }

  if (jwtAuthenticator) {
    var pathsPublic = [/^\/forest\/sessions.*$/];
    app.use(pathMounted, jwtAuthenticator.unless({
      path: pathsPublic
    }));
  }

  new HealthCheckRoute(app, opts).perform();
  new SessionRoute(app, opts).perform(); // Init

  buildSchema().then(function (models) {
    var directorySmartImplementation;

    if (opts.configDir) {
      directorySmartImplementation = path.resolve('.', opts.configDir);
    } else {
      directorySmartImplementation = "".concat(path.resolve('.'), "/forest");
    }

    if (fs.existsSync(directorySmartImplementation)) {
      return requireAllModels(directorySmartImplementation);
    }

    if (opts.configDir) {
      logger.error('The Forest configDir option you configured does not seem to be an existing directory.');
    }

    return models;
  }).each(function (model) {
    var modelName = configStore.Implementation.getModelName(model);
    configStore.integrator.defineRoutes(app, model, configStore.Implementation);
    var resourcesRoute = new ResourcesRoutes(app, model);
    resourcesRoute.perform();
    exports.ResourcesRoute[modelName] = resourcesRoute;
    new AssociationsRoutes(app, model, configStore.Implementation, configStore.integrator, configStore.lianaOptions).perform();
    new ActionsRoutes(app, model, configStore.Implementation, configStore.integrator, configStore.lianaOptions).perform();
    new StatRoutes(app, model, configStore.Implementation, configStore.lianaOptions).perform();
  }).then(function () {
    return new ForestRoutes(app, configStore.lianaOptions).perform();
  }).then(function () {
    return app.use(pathMounted, errorHandler.catchIfAny);
  }).then(function () {
    if (!opts.envSecret) {
      return;
    }

    if (opts.envSecret.length !== 64) {
      logger.error('Your envSecret does not seem to be correct. Can you check on Forest that you copied it properly in the Forest initialization?');
      return;
    }

    var collections = _.values(Schemas.schemas);

    configStore.integrator.defineCollections(collections);
    collections.filter(function (collection) {
      return collection.actions && collection.actions.length;
    }) // NOTICE: Check each Smart Action declaration to detect configuration errors.
    .forEach(function (collection) {
      var isFieldsInvalid = function isFieldsInvalid(action) {
        return action.fields && !Array.isArray(action.fields);
      };

      collection.actions.forEach(function (action) {
        if (!action.name) {
          logger.warn("An unnamed Smart Action of collection \"".concat(collection.name, "\" has been ignored."));
        } else if (isFieldsInvalid(action)) {
          logger.error("Cannot find the fields you defined for the Smart action \"".concat(action.name, "\" of your \"").concat(collection.name, "\" collection. The fields option must be an array."));
        }
      }); // NOTICE: Ignore actions without a name.

      collection.actions = collection.actions.filter(function (action) {
        return action.name;
      });
    });
    var schemaSerializer = new SchemaSerializer();
    var serializerOptions = schemaSerializer.options;
    var collectionsSent;
    var metaSent;

    if (ENVIRONMENT_DEVELOPMENT) {
      var expressVersion = process.env.npm_package_dependencies_express;
      var meta = {
        database_type: configStore.Implementation.getDatabaseType(),
        liana: configStore.Implementation.getLianaName(),
        liana_version: configStore.Implementation.getLianaVersion(),
        engine: 'nodejs',
        engine_version: process.versions && process.versions.node,
        framework: expressVersion ? 'express' : 'other',
        framework_version: expressVersion,
        orm_version: configStore.Implementation.getOrmVersion()
      };
      var content = new SchemaFileUpdater(SCHEMA_FILENAME, collections, meta, serializerOptions).perform();
      collectionsSent = content.collections;
      metaSent = content.meta;
    } else {
      try {
        var _content = fs.readFileSync(SCHEMA_FILENAME);

        if (!_content) {
          logger.error('The .forestadmin-schema.json file is empty.');
          logger.error('The schema cannot be synchronized with Forest Admin servers.');
          return;
        }

        var contentParsed = JSON.parse(_content.toString());
        collectionsSent = contentParsed.collections;
        metaSent = contentParsed.meta;
      } catch (error) {
        if (error.code === 'ENOENT') {
          logger.error('The .forestadmin-schema.json file does not exists.');
        } else {
          logger.error('The content of .forestadmin-schema.json file is not a correct JSON.');
        }

        logger.error('The schema cannot be synchronized with Forest Admin servers.');
        return;
      }
    }

    if (DISABLE_AUTO_SCHEMA_APPLY) {
      return;
    }

    var schemaSent = schemaSerializer.perform(collectionsSent, metaSent);
    new ApimapSender(opts.envSecret, schemaSent).perform();
  }).then(function () {
    return ipWhitelist.retrieve(opts.envSecret) // NOTICE: An error log (done by the service) is enough in case of retrieval error.
    ["catch"](function () {});
  })["catch"](function (error) {
    logger.error('An error occured while computing the Forest schema. Your application schema cannot be synchronized with Forest. Your admin panel might not reflect your application models definition. ', error);
  });

  if (opts.expressParentApp) {
    opts.expressParentApp.use('/forest', app);
  }

  return app;
};

exports.collection = function (name, opts) {
  if (_.isEmpty(Schemas.schemas) && opts.modelsDir) {
    logger.error("Cannot customize your collection named \"".concat(name, "\" properly. Did you call the \"collection\" method in the /forest directory?"));
    return;
  }

  var collection = _.find(Schemas.schemas, {
    name: name
  });

  if (!collection) {
    collection = _.find(Schemas.schemas, {
      nameOld: name
    });

    if (collection) {
      name = collection.name;
      logger.warn("DEPRECATION WARNING: Collection names are now based on the models names. Please rename the collection \"".concat(collection.nameOld, "\" of your Forest customisation in \"").concat(collection.name, "\"."));
    }
  }

  if (collection) {
    if (!Schemas.schemas[name].actions) {
      Schemas.schemas[name].actions = [];
    }

    if (!Schemas.schemas[name].segments) {
      Schemas.schemas[name].segments = [];
    }

    Schemas.schemas[name].actions = _.union(opts.actions, Schemas.schemas[name].actions);
    Schemas.schemas[name].segments = _.union(opts.segments, Schemas.schemas[name].segments); // NOTICE: Smart Field definition case

    opts.fields = new ApimapFieldsFormater(opts.fields, name).perform();
    Schemas.schemas[name].fields = _.concat(opts.fields, Schemas.schemas[name].fields);

    if (opts.searchFields) {
      Schemas.schemas[name].searchFields = opts.searchFields;
    }
  } else if (opts.fields && opts.fields.length) {
    // NOTICE: Smart Collection definition case
    opts.name = name;
    opts.idField = 'id';
    opts.isVirtual = true;
    opts.isSearchable = !!opts.isSearchable;
    opts.fields = new ApimapFieldsFormater(opts.fields, name).perform();
    Schemas.schemas[name] = opts;
  }
};

exports.logger = require('./services/logger');
exports.StatSerializer = require('./serializers/stat');
exports.ResourceSerializer = require('./serializers/resource');
exports.ResourceDeserializer = require('./deserializers/resource');
exports.BaseFiltersParser = require('./services/base-filters-parser');
exports.BaseOperatorDateParser = require('./services/base-operator-date-parser');
exports.RecordsGetter = require('./services/exposed/records-getter');
exports.RecordsCounter = require('./services/exposed/records-counter');
exports.RecordsExporter = require('./services/exposed/records-exporter');
exports.RecordGetter = require('./services/exposed/record-getter');
exports.RecordUpdater = require('./services/exposed/record-updater');
exports.RecordCreator = require('./services/exposed/record-creator');
exports.RecordRemover = require('./services/exposed/record-remover');
exports.RecordSerializer = require('./services/exposed/record-serializer');
exports.PermissionMiddlewareCreator = require('./middlewares/permissions');
exports.PUBLIC_ROUTES = ['/', '/healthcheck', '/sessions', '/sessions-google'];