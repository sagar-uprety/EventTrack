"use strict";

var _interopRequireDefault = require("babel-runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("babel-runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("babel-runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("babel-runtime/helpers/asyncToGenerator"));

var _lodash = _interopRequireDefault(require("lodash"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _moment = _interopRequireDefault(require("moment"));

require("moment-timezone");

var _forestExpress = _interopRequireDefault(require("forest-express"));

var _queryBuilder = _interopRequireDefault(require("./query-builder"));

var _schema = _interopRequireDefault(require("../utils/schema"));

/* eslint-disable no-underscore-dangle */
// NOTICE: moment-timezone extends moment itself,
//         Importing it will automatically add functions to moment.
function LineStatFinder(model, params, opts) {
  var schema = _forestExpress.default.Schemas.schemas[_schema.default.getModelName(model)];

  var timezone = -parseInt((0, _moment.default)().tz(params.timezone).format('Z'), 10);
  var timezoneOffset = timezone * 60 * 60 * 1000;
  var queryBuilder = new _queryBuilder.default(model, params, opts);

  function getReference(fieldName) {
    if (!fieldName) {
      return null;
    }

    var fieldNameWithoutSubField = fieldName.includes(':') ? fieldName.split(':')[0] : fieldName;

    var field = _lodash.default.find(schema.fields, {
      field: fieldNameWithoutSubField
    });

    return field.reference ? field : null;
  }

  function getFormat(momentRange) {
    switch (momentRange) {
      case 'day':
        return 'DD/MM/YYYY';

      case 'week':
        return '[W]w-YYYY';

      case 'month':
        return 'MMM YY';

      case 'year':
        return 'YYYY';

      default:
        return null;
    }
  }

  function formatLabel(record, momentRange) {
    switch (momentRange) {
      case 'day':
        return (0, _moment.default)().year(record._id.year).month(record._id.month - 1).startOf('month').add(record._id.day - 1, 'days').startOf(momentRange).format(getFormat(momentRange));

      case 'week':
        return (0, _moment.default)().year(record._id.year).week(record._id.week).startOf(momentRange).format(getFormat(momentRange));

      case 'month':
        return (0, _moment.default)().year(record._id.year).month(record._id.month - 1).startOf(momentRange).format(getFormat(momentRange));

      case 'year':
        return record._id.year.toString();

      default:
        return null;
    }
  }

  function setDate(record, momentRange) {
    switch (momentRange) {
      case 'day':
        return (0, _moment.default)().year(record._id.year).month(record._id.month - 1).startOf('month').add(record._id.day - 1, 'days').startOf(momentRange);

      case 'week':
        return (0, _moment.default)().year(record._id.year).week(record._id.week).startOf(momentRange);

      case 'month':
        return (0, _moment.default)().year(record._id.year).month(record._id.month - 1).startOf(momentRange);

      case 'year':
        return (0, _moment.default)().year(record._id.year).startOf(momentRange);

      default:
        return null;
    }
  }

  function fillEmptyIntervals(records, momentRange, firstDate, lastDate) {
    var newRecords = [];
    var currentDate = firstDate;

    while (currentDate <= lastDate) {
      var currentLabel = currentDate.format(getFormat(momentRange));

      var currentRecord = _lodash.default.find(records, {
        label: currentLabel
      });

      var value = currentRecord ? currentRecord.values.value : 0;
      newRecords.push({
        label: currentLabel,
        values: {
          value: value
        }
      });
      currentDate = currentDate.add(1, momentRange);
    }

    return newRecords;
  }

  this.perform = function () {
    var populateGroupByField = getReference(params.group_by_field);
    var groupByFieldName = populateGroupByField ? params.group_by_field.replace(':', '.') : params.group_by_field;
    return new _bluebird.default(function () {
      var _ref = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(resolve, reject) {
        var jsonQuery, groupBy, sort, sum, _$group, query;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return queryBuilder.getQueryWithFiltersAndJoins(null);

              case 2:
                jsonQuery = _context.sent;

                if (populateGroupByField) {
                  queryBuilder.addJoinToQuery(populateGroupByField, jsonQuery);
                }

                groupBy = {};
                sort = {};

                if (groupByFieldName) {
                  groupBy._id = "$".concat(groupByFieldName);
                }

                if (!params.group_by_date_field) {
                  _context.next = 23;
                  break;
                }

                _context.t0 = params.time_range;
                _context.next = _context.t0 === 'Day' ? 11 : _context.t0 === 'Week' ? 15 : _context.t0 === 'Year' ? 18 : 20;
                break;

              case 11:
                groupBy.year = {
                  $year: [{
                    $subtract: ["$".concat(params.group_by_date_field), timezoneOffset]
                  }]
                };
                groupBy.month = {
                  $month: [{
                    $subtract: ["$".concat(params.group_by_date_field), timezoneOffset]
                  }]
                };
                groupBy.day = {
                  $dayOfMonth: [{
                    $subtract: ["$".concat(params.group_by_date_field), timezoneOffset]
                  }]
                };
                return _context.abrupt("break", 22);

              case 15:
                groupBy.week = {
                  $week: [{
                    $subtract: ["$".concat(params.group_by_date_field), timezoneOffset]
                  }]
                };
                groupBy.year = {
                  $year: [{
                    $subtract: ["$".concat(params.group_by_date_field), timezoneOffset]
                  }]
                };
                return _context.abrupt("break", 22);

              case 18:
                groupBy.year = {
                  $year: [{
                    $subtract: ["$".concat(params.group_by_date_field), timezoneOffset]
                  }]
                };
                return _context.abrupt("break", 22);

              case 20:
                // Month
                groupBy.month = {
                  $month: [{
                    $subtract: ["$".concat(params.group_by_date_field), timezoneOffset]
                  }]
                };
                groupBy.year = {
                  $year: [{
                    $subtract: ["$".concat(params.group_by_date_field), timezoneOffset]
                  }]
                };

              case 22:
                sort[params.group_by_date_field] = 1;

              case 23:
                sum = 1;

                if (params.aggregate_field) {
                  sum = "$".concat(params.aggregate_field);
                }

                if (params.group_by_date_field) {
                  jsonQuery.push({
                    $match: (0, _defineProperty2.default)({}, params.group_by_date_field, {
                      $ne: null
                    })
                  });
                }

                if (groupBy) {
                  jsonQuery.push({
                    $group: (_$group = {
                      _id: groupBy
                    }, (0, _defineProperty2.default)(_$group, params.group_by_date_field, {
                      $first: "$".concat(params.group_by_date_field)
                    }), (0, _defineProperty2.default)(_$group, "count", {
                      $sum: sum
                    }), _$group)
                  });
                }

                query = model.aggregate(jsonQuery);
                query.sort(sort).project({
                  values: {
                    key: '$_id',
                    value: '$count'
                  }
                }).exec(function (error, records) {
                  return error ? reject(error) : resolve(records);
                });

              case 29:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }()).then(function (records) {
      if (!records.length) {
        return {
          value: []
        };
      }

      var momentRange = params.time_range.toLowerCase();
      var firstDate = setDate(records[0], momentRange);
      var lastDate = setDate(records[records.length - 1], momentRange);
      records = records.map(function (record) {
        return {
          label: formatLabel(record, momentRange),
          values: record.values
        };
      });
      return {
        value: fillEmptyIntervals(records, momentRange, firstDate, lastDate)
      };
    });
  };
}

module.exports = LineStatFinder;