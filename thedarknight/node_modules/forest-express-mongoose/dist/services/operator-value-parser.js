"use strict";

var _interopRequireDefault = require("babel-runtime/helpers/interopRequireDefault");

var _lodash = _interopRequireDefault(require("lodash"));

var _moment = _interopRequireDefault(require("moment"));

var _forestExpress = _interopRequireDefault(require("forest-express"));

var _schema = _interopRequireDefault(require("../utils/schema"));

var PERIODS_PAST = '$past';
var PERIODS_FUTURE = '$future';
var PERIODS_TODAY = '$today';
var PERIODS_YESTERDAY = '$yesterday';
var PERIODS_PREVIOUS_WEEK = '$previousWeek';
var PERIODS_PREVIOUS_MONTH = '$previousMonth';
var PERIODS_PREVIOUS_QUARTER = '$previousQuarter';
var PERIODS_PREVIOUS_YEAR = '$previousYear';
var PERIODS_WEEK_TO_DATE = '$weekToDate';
var PERIODS_MONTH_TO_DATE = '$monthToDate';
var PERIODS_QUARTER_TO_DATE = '$quarterToDate';
var PERIODS_YEAR_TO_DATE = '$yearToDate';
var VALUES_DATE = [PERIODS_PAST, PERIODS_FUTURE, PERIODS_TODAY, PERIODS_YESTERDAY, PERIODS_PREVIOUS_WEEK, PERIODS_PREVIOUS_MONTH, PERIODS_PREVIOUS_QUARTER, PERIODS_PREVIOUS_YEAR, PERIODS_WEEK_TO_DATE, PERIODS_MONTH_TO_DATE, PERIODS_QUARTER_TO_DATE, PERIODS_YEAR_TO_DATE];
var PERIODS_PREVIOUS_X_DAYS = /^\$previous(\d+)Days$/;
var PERIODS_X_DAYS_TO_DATE = /^\$(\d+)DaysToDate$/;
var PERIODS_X_HOURS_BEFORE = /^\$(\d+)HoursBefore$/;
var PERIODS_X_HOURS_AFTER = /^\$(\d+)HoursAfter$/;

function OperatorValueParser(opts, timezone) {
  var _this = this;

  var offsetClient = parseInt(timezone, 10);
  var offsetServer = (0, _moment.default)().utcOffset() / 60;
  var offsetHours = offsetServer - offsetClient;

  this.perform = function (model, key, value) {
    var schema = _forestExpress.default.Schemas.schemas[_schema.default.getModelName(model)];

    var parseFct = function parseFct(val) {
      return val;
    };

    var ret = null;
    var fieldValues = key.split(':');
    var fieldName = fieldValues[0];
    var subfieldName = fieldValues[1]; // Mongoose Aggregate don't parse the value automatically.

    var field = _lodash.default.find(schema.fields, {
      field: fieldName
    });

    var isEmbeddedField = !!field.type.fields;

    if (isEmbeddedField) {
      field = _lodash.default.find(field.type.fields, {
        field: subfieldName
      });
    }

    if (field) {
      switch (field.type) {
        case 'Number':
          parseFct = parseInt;
          break;

        case 'Date':
          parseFct = function parseFct(val) {
            return new Date(val);
          };

          break;

        case 'Boolean':
          parseFct = function parseFct(val) {
            if (val === 'true') {
              return true;
            }

            if (val === 'false') {
              return false;
            }

            return null;
          };

          break;

        case 'String':
          parseFct = function parseFct(val) {
            // NOTICE: Check if the value is a real ObjectID. By default, the
            // isValid method returns true for a random string with length 12.
            // Example: 'Black Friday'.
            if (opts.mongoose.Types.ObjectId.isValid(val) && opts.mongoose.Types.ObjectId(val).toString() === val) {
              return opts.mongoose.Types.ObjectId(val);
            }

            return val;
          };

          break;

        default:
          break;
      }

      if (_lodash.default.isArray(field.type)) {
        parseFct = function parseFct(val) {
          return {
            $size: val
          };
        };
      }
    }

    if (value[0] === '!' && value[1] !== '*') {
      value = value.substring(1);
      ret = {
        $ne: parseFct(value)
      };
    } else if (value[0] === '>') {
      value = value.substring(1);
      ret = {
        $gt: parseFct(value)
      };
    } else if (value[0] === '<') {
      value = value.substring(1);
      ret = {
        $lt: parseFct(value)
      };
    } else if (value[0] === '*' && value[value.length - 1] === '*') {
      value = value.substring(1, value.length - 1);
      ret = new RegExp(".*".concat(parseFct(value), ".*"));
    } else if (value[0] === '!' && value[1] === '*' && value[value.length - 1] === '*') {
      value = value.substring(2, value.length - 1);
      ret = {
        $not: new RegExp(".*".concat(parseFct(value), ".*"))
      };
    } else if (value[0] === '*') {
      value = value.substring(1);
      ret = new RegExp(".*".concat(parseFct(value), "$"));
    } else if (value[value.length - 1] === '*') {
      value = value.substring(0, value.length - 1);
      ret = new RegExp("^".concat(parseFct(value), ".*"));
    } else if (value === '$present') {
      ret = {
        $exists: true
      };
    } else if (value === '$blank') {
      ret = {
        $exists: false
      };
    } else if (_this.isIntervalDateValue(value)) {
      ret = _this.getIntervalDateValue(value);
    } else {
      ret = parseFct(value);
    }

    return ret;
  };

  this.getIntervalDateValue = function (currentValue) {
    var from = null;
    var to = null;

    if (currentValue === PERIODS_FUTURE) {
      return {
        $gte: (0, _moment.default)().toDate()
      };
    }

    if (currentValue === PERIODS_PAST) {
      return {
        $lte: (0, _moment.default)().toDate()
      };
    }

    if (currentValue === PERIODS_TODAY) {
      return {
        $gte: (0, _moment.default)().startOf('day').add(offsetHours, 'h').toDate(),
        $lte: (0, _moment.default)().endOf('day').add(offsetHours, 'h').toDate()
      };
    }

    var match = currentValue.match(PERIODS_PREVIOUS_X_DAYS);

    if (match && match[1]) {
      return {
        $gte: (0, _moment.default)().subtract(match[1], 'days').startOf('day').add(offsetHours, 'h').toDate(),
        $lte: (0, _moment.default)().subtract(1, 'days').endOf('day').add(offsetHours, 'h').toDate()
      };
    }

    match = currentValue.match(PERIODS_X_DAYS_TO_DATE);

    if (match && match[1]) {
      return {
        $gte: (0, _moment.default)().subtract(match[1] - 1, 'days').startOf('day').toDate(),
        $lte: (0, _moment.default)().toDate()
      };
    }

    match = currentValue.match(PERIODS_X_HOURS_BEFORE);

    if (match && match[1]) {
      return {
        $lte: (0, _moment.default)().subtract(match[1], 'hours').toDate()
      };
    }

    match = currentValue.match(PERIODS_X_HOURS_AFTER);

    if (match && match[1]) {
      return {
        $gte: (0, _moment.default)().subtract(match[1], 'hours').toDate()
      };
    }

    switch (currentValue) {
      case PERIODS_YESTERDAY:
        from = (0, _moment.default)().subtract(1, 'days').startOf('day').add(offsetHours, 'h').toDate();
        to = (0, _moment.default)().subtract(1, 'days').endOf('day').add(offsetHours, 'h').toDate();
        break;

      case PERIODS_PREVIOUS_WEEK:
        from = (0, _moment.default)().subtract(1, 'weeks').startOf('isoWeek').add(offsetHours, 'h').toDate();
        to = (0, _moment.default)().subtract(1, 'weeks').endOf('isoWeek').add(offsetHours, 'h').toDate();
        break;

      case PERIODS_PREVIOUS_MONTH:
        from = (0, _moment.default)().subtract(1, 'months').startOf('month').add(offsetHours, 'h').toDate();
        to = (0, _moment.default)().subtract(1, 'months').endOf('month').add(offsetHours, 'h').toDate();
        break;

      case PERIODS_PREVIOUS_QUARTER:
        from = (0, _moment.default)().subtract(1, 'quarters').startOf('quarter').add(offsetHours, 'h').toDate();
        to = (0, _moment.default)().subtract(1, 'quarters').endOf('quarter').add(offsetHours, 'h').toDate();
        break;

      case PERIODS_PREVIOUS_YEAR:
        from = (0, _moment.default)().subtract(1, 'years').startOf('year').add(offsetHours, 'h').toDate();
        to = (0, _moment.default)().subtract(1, 'years').endOf('year').add(offsetHours, 'h').toDate();
        break;

      case PERIODS_WEEK_TO_DATE:
        from = (0, _moment.default)().startOf('week').add(offsetHours, 'h').toDate();
        to = (0, _moment.default)().toDate();
        break;

      case PERIODS_MONTH_TO_DATE:
        from = (0, _moment.default)().startOf('month').add(offsetHours, 'h').toDate();
        to = (0, _moment.default)().toDate();
        break;

      case PERIODS_QUARTER_TO_DATE:
        from = (0, _moment.default)().startOf('quarter').add(offsetHours, 'h').toDate();
        to = (0, _moment.default)().toDate();
        break;

      case PERIODS_YEAR_TO_DATE:
        from = (0, _moment.default)().startOf('year').add(offsetHours, 'h').toDate();
        to = (0, _moment.default)().toDate();
        break;

      default:
        break;
    }

    return {
      $gte: from,
      $lte: to
    };
  };

  this.isIntervalDateValue = function (currentValue) {
    var match = currentValue.match(PERIODS_PREVIOUS_X_DAYS);

    if (match && match[1]) {
      return true;
    }

    match = currentValue.match(PERIODS_X_DAYS_TO_DATE);

    if (match && match[1]) {
      return true;
    }

    match = currentValue.match(PERIODS_X_HOURS_BEFORE);

    if (match && match[1]) {
      return true;
    }

    match = currentValue.match(PERIODS_X_HOURS_AFTER);

    if (match && match[1]) {
      return true;
    }

    return VALUES_DATE.indexOf(currentValue) !== -1;
  };
}

module.exports = OperatorValueParser;