var _regeneratorRuntime = require("babel-runtime/regenerator");

var _asyncToGenerator = require("babel-runtime/helpers/asyncToGenerator");

var _ = require('lodash');

var Interface = require('forest-express');

var utils = require('../utils/schema');

function SearchBuilder(model, opts, params, searchFields) {
  var _this = this;

  var schema = Interface.Schemas.schemas[utils.getModelName(model)];
  var fieldsSearched = [];
  this.hasSmartFieldSearch = false;

  this.getFieldsSearched = function () {
    return fieldsSearched;
  };

  this.getConditions = _asyncToGenerator(
  /*#__PURE__*/
  _regeneratorRuntime.mark(function _callee2() {
    var orQuery, pushCondition, promises;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            pushCondition = function pushCondition(condition, fieldName) {
              orQuery.$or.push(condition);
              fieldsSearched.push(fieldName);
            };

            _this.hasSmartFieldSearch = false;
            orQuery = {
              $or: []
            };

            _.each(model.schema.paths, function (value, key) {
              if (searchFields && !searchFields.includes(value.path)) {
                return;
              }

              var condition = {};
              var searchValue = params.search.replace(/[-[\]{}()*+!<=:?./\\^$|#\s,]/g, '\\$&');
              var searchRegexp = new RegExp(".*".concat(searchValue, ".*"), 'i');

              if (value.instance === 'ObjectID') {
                if (new RegExp('^[0-9a-fA-F]{24}$').test(params.search)) {
                  condition[key] = opts.mongoose.Types.ObjectId(params.search);
                  pushCondition(condition, key);
                }
              } else if (value.instance === 'Number') {
                var searchNumber = Number(params.search);

                if (!Number.isNaN(searchNumber)) {
                  condition[key] = searchNumber;
                  pushCondition(condition, key);
                }
              } else if (value.instance === 'String') {
                condition[key] = searchRegexp;
                pushCondition(condition, key);
              } else if (value.instance === 'Array') {
                var field = _.find(schema.fields, {
                  field: key
                });

                if (field && _.isArray(field.type) && field.type[0] === 'String' && !field.reference) {
                  condition[key] = searchRegexp;
                  pushCondition(condition, key);
                } else if (field && _.isArray(field.type) && !field.reference && Number.parseInt(params.searchExtended, 10)) {
                  var elemMatch = {
                    $elemMatch: {
                      $or: []
                    }
                  };
                  field.type[0].fields.forEach(function (subField) {
                    var query = {};

                    if (subField.type === 'String' && !value.schema.obj[subField.field].ref) {
                      query[subField.field] = searchRegexp;
                      elemMatch.$elemMatch.$or.push(query);
                    } else if (subField.type === 'Number' && Number.parseInt(params.search, 10)) {
                      query[subField.field] = Number.parseInt(params.search, 10);
                      elemMatch.$elemMatch.$or.push(query);
                    }
                  });
                  condition[key] = elemMatch;
                  pushCondition(condition, key);
                }
              }
            });

            promises = [];

            _.each(schema.fields, function (field) {
              if (field.search) {
                // eslint-disable-next-line no-async-promise-executor
                var promise = new Promise(function () {
                  var _ref2 = _asyncToGenerator(
                  /*#__PURE__*/
                  _regeneratorRuntime.mark(function _callee(resolve) {
                    var condition;
                    return _regeneratorRuntime.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            _context.prev = 0;
                            _context.next = 3;
                            return Promise.resolve(field.search(params.search));

                          case 3:
                            condition = _context.sent;

                            if (condition) {
                              pushCondition(condition, field.field);
                            }

                            _this.hasSmartFieldSearch = true;
                            _context.next = 11;
                            break;

                          case 8:
                            _context.prev = 8;
                            _context.t0 = _context["catch"](0);
                            Interface.logger.error("Cannot search properly on Smart Field ".concat(field.field), _context.t0);

                          case 11:
                            resolve();

                          case 12:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee, this, [[0, 8]]);
                  }));

                  return function (_x) {
                    return _ref2.apply(this, arguments);
                  };
                }());
                promises.push(promise);
              }
            });

            _context2.next = 8;
            return Promise.all(promises);

          case 8:
            return _context2.abrupt("return", orQuery.$or.length ? orQuery : {});

          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  this.getWhere = function () {
    var _ref3 = _asyncToGenerator(
    /*#__PURE__*/
    _regeneratorRuntime.mark(function _callee3(jsonQuery) {
      return _regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.t0 = jsonQuery;
              _context3.next = 3;
              return _this.getConditions();

            case 3:
              _context3.t1 = _context3.sent;

              _context3.t0.push.call(_context3.t0, _context3.t1);

            case 5:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    return function (_x2) {
      return _ref3.apply(this, arguments);
    };
  }();
}

module.exports = SearchBuilder;