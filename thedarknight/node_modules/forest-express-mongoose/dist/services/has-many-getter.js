var _regeneratorRuntime = require("babel-runtime/regenerator");

var _asyncToGenerator = require("babel-runtime/helpers/asyncToGenerator");

var _ = require('lodash');

var P = require('bluebird');

var Interface = require('forest-express');

var SearchBuilder = require('./search-builder');

var utils = require('../utils/schema');

function HasManyGetter(model, association, opts, params) {
  var OBJECTID_REGEXP = /^[0-9a-fA-F]{24}$/;
  var schema = Interface.Schemas.schemas[utils.getModelName(association)];
  var searchBuilder = new SearchBuilder(association, opts, params);

  function hasPagination() {
    return params.page && params.page.number;
  }

  function getLimit() {
    if (hasPagination()) {
      return parseInt(params.page.number, 10) * params.page.size;
    }

    return 5;
  }

  function getSkip() {
    if (hasPagination()) {
      return (parseInt(params.page.number, 10) - 1) * params.page.size;
    }

    return 0;
  }

  function getProjection() {
    var projection = {};
    projection[params.associationName] = 1;
    projection._id = 0; // eslint-disable-line

    return projection;
  }

  function handlePopulate(query) {
    _.each(schema.fields, function (field) {
      if (field.reference) {
        query.populate({
          path: field.field
        });
      }
    });
  }

  function getRecordsAndRecordIds() {
    return new P(function (resolve, reject) {
      var id = params.recordId;

      if (OBJECTID_REGEXP.test(params.recordId)) {
        id = opts.mongoose.Types.ObjectId(id);
      }

      return model.aggregate().match({
        _id: id
      }).unwind(params.associationName).project(getProjection()).exec(function (error, records) {
        if (error) {
          return reject(error);
        }

        return resolve(_.map(records, function (record) {
          return record[params.associationName];
        }));
      });
    }).then(function () {
      var _ref = _asyncToGenerator(
      /*#__PURE__*/
      _regeneratorRuntime.mark(function _callee(recordIds) {
        var conditions, conditionsSearch, query;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                conditions = {
                  $and: [{
                    _id: {
                      $in: recordIds
                    }
                  }]
                };

                if (!params.search) {
                  _context.next = 6;
                  break;
                }

                _context.next = 4;
                return searchBuilder.getConditions();

              case 4:
                conditionsSearch = _context.sent;
                conditions.$and.push(conditionsSearch);

              case 6:
                query = association.find(conditions);
                handlePopulate(query);
                return _context.abrupt("return", query.then(function (records) {
                  return [records, recordIds];
                }));

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
  }

  this.perform = function () {
    return getRecordsAndRecordIds().then(function (recordsAndRecordIds) {
      var records = recordsAndRecordIds[0];
      var fieldSort = params.sort;
      var descending = false;

      if (params.sort && params.sort[0] === '-') {
        fieldSort = params.sort.substring(1);
        descending = true;
      }

      var recordsSorted;

      if (fieldSort) {
        recordsSorted = _.sortBy(records, function (record) {
          return record[fieldSort];
        });
      } else {
        var recordIds = recordsAndRecordIds[1]; // NOTICE: Convert values to strings, so ObjectIds could be easily searched and compared.

        var recordIdStrings = recordIds.map(function (recordId) {
          return String(recordId);
        }); // NOTICE: indexOf could be improved by making a Map from record-ids to their index.

        recordsSorted = _.sortBy(records, function (record) {
          return recordIdStrings.indexOf(String(record._id));
        }); // eslint-disable-line
      }

      return descending ? recordsSorted.reverse() : recordsSorted;
    }).then(function (records) {
      var fieldsSearched = null;

      if (params.search) {
        fieldsSearched = searchBuilder.getFieldsSearched();
      }

      records = _.slice(records, getSkip(), getSkip() + getLimit());
      return [records, fieldsSearched];
    });
  };

  this.count = function () {
    return getRecordsAndRecordIds().then(function (recordsAndRecordIds) {
      return recordsAndRecordIds[0].length;
    });
  };
}

module.exports = HasManyGetter;