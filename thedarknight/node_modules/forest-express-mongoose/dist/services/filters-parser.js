"use strict";

var _interopRequireWildcard = require("babel-runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("babel-runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("babel-runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("babel-runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("babel-runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("babel-runtime/helpers/asyncToGenerator"));

var _lodash = _interopRequireDefault(require("lodash"));

var _forestExpress = _interopRequireWildcard(require("forest-express"));

var _errors = require("./errors");

var _schema = _interopRequireDefault(require("../utils/schema"));

var AGGREGATOR_OPERATORS = ['and', 'or'];

function FiltersParser(model, timezone, options) {
  var _this = this;

  var schema = _forestExpress.default.Schemas.schemas[_schema.default.getModelName(model)];

  var parseInteger = function parseInteger(value) {
    return Number.parseInt(value, 10);
  };

  var parseDate = function parseDate(value) {
    return new Date(value);
  };

  var parseBoolean = function parseBoolean(value) {
    if (value === 'true') {
      return true;
    }

    if (value === 'false') {
      return false;
    }

    return typeof value === 'boolean' ? value : null;
  };

  var parseString = function parseString(value) {
    // NOTICE: Check if the value is a real ObjectID. By default, the isValid method returns true
    //         for a random string with length 12 (example: 'Black Friday').
    var ObjectId = options.mongoose.Types.ObjectId;

    if (ObjectId.isValid(value) && ObjectId(value).toString() === value) {
      return ObjectId(value);
    }

    return value;
  };

  var parseArray = function parseArray(value) {
    return {
      $size: value
    };
  };

  var parseOther = function parseOther(value) {
    return value;
  };

  this.operatorDateParser = new _forestExpress.BaseOperatorDateParser({
    operators: {
      GTE: '$gte',
      LTE: '$lte'
    },
    timezone: timezone
  });

  this.perform = function () {
    var _ref = (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee(filtersString) {
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", _forestExpress.BaseFiltersParser.perform(filtersString, _this.formatAggregation, _this.formatCondition));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }();

  this.formatAggregation = function () {
    var _ref2 = (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee2(aggregator, formatedConditions) {
      var aggregatorOperator;
      return _regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              aggregatorOperator = _this.formatAggregatorOperator(aggregator);
              return _context2.abrupt("return", (0, _defineProperty2.default)({}, aggregatorOperator, formatedConditions));

            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    return function (_x2, _x3) {
      return _ref2.apply(this, arguments);
    };
  }();

  this.formatCondition = function () {
    var _ref4 = (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee3(condition) {
      var formatedField;
      return _regenerator.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!_lodash.default.isEmpty(condition)) {
                _context3.next = 2;
                break;
              }

              throw new _errors.InvalidFiltersFormatError('Empty condition in filter');

            case 2:
              if (_lodash.default.isObject(condition)) {
                _context3.next = 4;
                break;
              }

              throw new _errors.InvalidFiltersFormatError('Condition cannot be a raw value');

            case 4:
              if (!_lodash.default.isArray(condition)) {
                _context3.next = 6;
                break;
              }

              throw new _errors.InvalidFiltersFormatError('Filters cannot be a raw array');

            case 6:
              if (!(!_lodash.default.isString(condition.field) || !_lodash.default.isString(condition.operator) || _lodash.default.isUndefined(condition.value))) {
                _context3.next = 8;
                break;
              }

              throw new _errors.InvalidFiltersFormatError('Invalid condition format');

            case 8:
              formatedField = _this.formatField(condition.field);
              _context3.t0 = _defineProperty2.default;
              _context3.t1 = {};
              _context3.t2 = formatedField;
              _context3.next = 14;
              return _this.formatOperatorValue(condition.field, condition.operator, condition.value);

            case 14:
              _context3.t3 = _context3.sent;
              return _context3.abrupt("return", (0, _context3.t0)(_context3.t1, _context3.t2, _context3.t3));

            case 16:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    return function (_x4) {
      return _ref4.apply(this, arguments);
    };
  }();

  this.getParserForType = function (type) {
    switch (type) {
      case 'Number':
        return parseInteger;

      case 'Date':
        return parseDate;

      case 'Boolean':
        return parseBoolean;

      case 'String':
        return parseString;

      case _lodash.default.isArray(type):
        return parseArray;

      default:
        return parseOther;
    }
  };

  this.getParserForField = function () {
    var _ref6 = (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee4(key) {
      var _key$split, _key$split2, fieldName, subfieldName, field, isEmbeddedField, parse;

      return _regenerator.default.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _key$split = key.split(':'), _key$split2 = (0, _slicedToArray2.default)(_key$split, 2), fieldName = _key$split2[0], subfieldName = _key$split2[1]; // NOTICE: Mongoose Aggregate don't parse the value automatically.

              field = _lodash.default.find(schema.fields, {
                field: fieldName
              });

              if (field) {
                _context4.next = 4;
                break;
              }

              throw new _errors.InvalidFiltersFormatError("Field '".concat(fieldName, "' not found on collection '").concat(schema.name, "'"));

            case 4:
              isEmbeddedField = !!field.type.fields;

              if (isEmbeddedField) {
                field = _lodash.default.find(field.type.fields, {
                  field: subfieldName
                });
              }

              if (field) {
                _context4.next = 8;
                break;
              }

              return _context4.abrupt("return", function (val) {
                return val;
              });

            case 8:
              parse = _this.getParserForType(field.type);
              return _context4.abrupt("return", function (value) {
                if (value && _lodash.default.isArray(value)) {
                  return value.map(parse);
                }

                return parse(value);
              });

            case 10:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    return function (_x5) {
      return _ref6.apply(this, arguments);
    };
  }();

  this.formatAggregatorOperator = function (aggregatorOperator) {
    if (AGGREGATOR_OPERATORS.includes(aggregatorOperator)) return "$".concat(aggregatorOperator);
    throw new _errors.NoMatchingOperatorError();
  };

  this.formatOperatorValue = function () {
    var _ref7 = (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee5(field, operator, value) {
      var parseFct;
      return _regenerator.default.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (!_this.operatorDateParser.isDateOperator(operator)) {
                _context5.next = 2;
                break;
              }

              return _context5.abrupt("return", _this.operatorDateParser.getDateFilter(operator, value));

            case 2:
              _context5.next = 4;
              return _this.getParserForField(field);

            case 4:
              parseFct = _context5.sent;
              _context5.t0 = operator;
              _context5.next = _context5.t0 === 'not' ? 8 : _context5.t0 === 'not_equal' ? 8 : _context5.t0 === 'greater_than' ? 9 : _context5.t0 === 'after' ? 9 : _context5.t0 === 'less_than' ? 10 : _context5.t0 === 'before' ? 10 : _context5.t0 === 'contains' ? 11 : _context5.t0 === 'starts_with' ? 12 : _context5.t0 === 'ends_with' ? 13 : _context5.t0 === 'not_contains' ? 14 : _context5.t0 === 'present' ? 15 : _context5.t0 === 'blank' ? 16 : _context5.t0 === 'equal' ? 17 : _context5.t0 === 'in' ? 18 : 19;
              break;

            case 8:
              return _context5.abrupt("return", {
                $ne: parseFct(value)
              });

            case 9:
              return _context5.abrupt("return", {
                $gt: parseFct(value)
              });

            case 10:
              return _context5.abrupt("return", {
                $lt: parseFct(value)
              });

            case 11:
              return _context5.abrupt("return", new RegExp(".*".concat(parseFct(value), ".*")));

            case 12:
              return _context5.abrupt("return", new RegExp("^".concat(parseFct(value), ".*")));

            case 13:
              return _context5.abrupt("return", new RegExp(".*".concat(parseFct(value), "$")));

            case 14:
              return _context5.abrupt("return", {
                $not: new RegExp(".*".concat(parseFct(value), ".*"))
              });

            case 15:
              return _context5.abrupt("return", {
                $exists: true
              });

            case 16:
              return _context5.abrupt("return", null);

            case 17:
              return _context5.abrupt("return", parseFct(value));

            case 18:
              return _context5.abrupt("return", {
                $in: parseFct(value)
              });

            case 19:
              throw new _errors.NoMatchingOperatorError();

            case 20:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    return function (_x6, _x7, _x8) {
      return _ref7.apply(this, arguments);
    };
  }();

  this.formatField = function (field) {
    return field.replace(':', '.');
  };

  this.getAssociations = function () {
    var _ref8 = (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee6(filtersString) {
      return _regenerator.default.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              return _context6.abrupt("return", _forestExpress.BaseFiltersParser.getAssociations(filtersString));

            case 1:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    return function (_x9) {
      return _ref8.apply(this, arguments);
    };
  }();

  this.formatAggregationForReferences = function (aggregator, conditions) {
    return {
      aggregator: aggregator,
      conditions: conditions
    };
  };

  this.formatConditionForReferences = function () {
    var _ref9 = (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee7(condition) {
      var _this$formatField$spl, _this$formatField$spl2, fieldName, subFieldName, field, subModel, subModelFilterParser, newCondition, query, _field$reference$spli, _field$reference$spli2, referencedKey, subModelIds, resultCondition;

      return _regenerator.default.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (!_lodash.default.isEmpty(condition)) {
                _context7.next = 2;
                break;
              }

              throw new _errors.InvalidFiltersFormatError('Empty condition in filter');

            case 2:
              if (_lodash.default.isObject(condition)) {
                _context7.next = 4;
                break;
              }

              throw new _errors.InvalidFiltersFormatError('Condition cannot be a raw value');

            case 4:
              if (!_lodash.default.isArray(condition)) {
                _context7.next = 6;
                break;
              }

              throw new _errors.InvalidFiltersFormatError('Filters cannot be a raw array');

            case 6:
              if (!(!_lodash.default.isString(condition.field) || !_lodash.default.isString(condition.operator) || _lodash.default.isUndefined(condition.value))) {
                _context7.next = 8;
                break;
              }

              throw new _errors.InvalidFiltersFormatError('Invalid condition format');

            case 8:
              _this$formatField$spl = _this.formatField(condition.field).split('.'), _this$formatField$spl2 = (0, _slicedToArray2.default)(_this$formatField$spl, 2), fieldName = _this$formatField$spl2[0], subFieldName = _this$formatField$spl2[1];

              if (subFieldName) {
                _context7.next = 11;
                break;
              }

              return _context7.abrupt("return", condition);

            case 11:
              // Mongoose Aggregate don't parse the value automatically.
              field = _lodash.default.find(schema.fields, {
                field: fieldName
              });

              if (field) {
                _context7.next = 14;
                break;
              }

              throw new _errors.InvalidFiltersFormatError("Field '".concat(fieldName, "' not found on collection '").concat(schema.name, "'"));

            case 14:
              if (field.reference) {
                _context7.next = 16;
                break;
              }

              return _context7.abrupt("return", condition);

            case 16:
              subModel = _schema.default.getReferenceModel(options, field.reference);
              subModelFilterParser = new FiltersParser(subModel, timezone, options);
              newCondition = {
                operator: condition.operator,
                value: condition.value,
                field: subFieldName
              };
              _context7.next = 21;
              return subModelFilterParser.perform(JSON.stringify(newCondition));

            case 21:
              query = _context7.sent;
              _field$reference$spli = field.reference.split('.'), _field$reference$spli2 = (0, _slicedToArray2.default)(_field$reference$spli, 2), referencedKey = _field$reference$spli2[1];
              _context7.next = 25;
              return subModel.find(query).then(function (records) {
                return records.map(function (record) {
                  return record[referencedKey];
                });
              });

            case 25:
              subModelIds = _context7.sent;
              resultCondition = {
                field: fieldName,
                operator: 'in',
                value: subModelIds
              };

              if (!(condition.operator === 'blank')) {
                _context7.next = 29;
                break;
              }

              return _context7.abrupt("return", {
                aggregator: 'or',
                conditions: [{
                  field: fieldName,
                  operator: 'blank',
                  value: null
                }, resultCondition]
              });

            case 29:
              return _context7.abrupt("return", resultCondition);

            case 30:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    return function (_x10) {
      return _ref9.apply(this, arguments);
    };
  }();

  this.replaceAllReferences = function () {
    var _ref10 = (0, _asyncToGenerator2.default)(
    /*#__PURE__*/
    _regenerator.default.mark(function _callee8(filtersString) {
      return _regenerator.default.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              return _context8.abrupt("return", _forestExpress.BaseFiltersParser.perform(filtersString, _this.formatAggregationForReferences, _this.formatConditionForReferences));

            case 1:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    return function (_x11) {
      return _ref10.apply(this, arguments);
    };
  }();
}

module.exports = FiltersParser;